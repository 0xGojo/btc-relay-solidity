/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface RelayInterface extends Interface {
  functions: {
    CONFIRMATIONS: TypedFunctionDescription<{ encode([]: []): string }>;

    DIFFICULTY_ADJUSTMENT_INTERVAL: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    DIFF_TARGET: TypedFunctionDescription<{ encode([]: []): string }>;

    MAIN_CHAIN_ID: TypedFunctionDescription<{ encode([]: []): string }>;

    bestBlock: TypedFunctionDescription<{ encode([]: []): string }>;

    bestHeight: TypedFunctionDescription<{ encode([]: []): string }>;

    bestScore: TypedFunctionDescription<{ encode([]: []): string }>;

    chain: TypedFunctionDescription<{ encode([]: [BigNumberish]): string }>;

    epochStartTarget: TypedFunctionDescription<{ encode([]: []): string }>;

    epochStartTime: TypedFunctionDescription<{ encode([]: []): string }>;

    forks: TypedFunctionDescription<{ encode([]: [BigNumberish]): string }>;

    getHashAtHeight: TypedFunctionDescription<{
      encode([_height]: [BigNumberish]): string;
    }>;

    getHeaderByHash: TypedFunctionDescription<{
      encode([_digest]: [Arrayish]): string;
    }>;

    headers: TypedFunctionDescription<{ encode([]: [Arrayish]): string }>;

    isCorrectDifficultyTarget: TypedFunctionDescription<{
      encode([
        prevStartTarget,
        prevStartTime,
        prevEndTarget,
        prevEndTime,
        nextTarget,
        _height
      ]: [
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    submitBlockHeader: TypedFunctionDescription<{
      encode([_header]: [Arrayish]): string;
    }>;

    verifyTx: TypedFunctionDescription<{
      encode([_height, _index, _txid, _proof, _confirmations, _insecure]: [
        BigNumberish,
        BigNumberish,
        Arrayish,
        Arrayish,
        BigNumberish,
        boolean
      ]): string;
    }>;
  };

  events: {
    ChainReorg: TypedEventDescription<{
      encodeTopics([_from, _to, _id]: [
        Arrayish | null,
        Arrayish | null,
        BigNumberish | null
      ]): string[];
    }>;

    StoreHeader: TypedEventDescription<{
      encodeTopics([_digest, _height]: [
        Arrayish | null,
        BigNumberish | null
      ]): string[];
    }>;
  };
}

export class Relay extends Contract {
  connect(signerOrProvider: Signer | Provider | string): Relay;
  attach(addressOrName: string): Relay;
  deployed(): Promise<Relay>;

  on(event: EventFilter | string, listener: Listener): Relay;
  once(event: EventFilter | string, listener: Listener): Relay;
  addListener(eventName: EventFilter | string, listener: Listener): Relay;
  removeAllListeners(eventName: EventFilter | string): Relay;
  removeListener(eventName: any, listener: Listener): Relay;

  interface: RelayInterface;

  functions: {
    CONFIRMATIONS(): Promise<BigNumber>;

    DIFFICULTY_ADJUSTMENT_INTERVAL(): Promise<BigNumber>;

    DIFF_TARGET(): Promise<BigNumber>;

    MAIN_CHAIN_ID(): Promise<BigNumber>;

    bestBlock(): Promise<string>;

    bestHeight(): Promise<BigNumber>;

    bestScore(): Promise<BigNumber>;

    chain(arg0: BigNumberish): Promise<string>;

    epochStartTarget(): Promise<BigNumber>;

    epochStartTime(): Promise<BigNumber>;

    forks(
      arg0: BigNumberish
    ): Promise<{
      height: BigNumber;
      ancestor: string;
      0: BigNumber;
      1: string;
    }>;

    getHashAtHeight(_height: BigNumberish): Promise<string>;

    getHeaderByHash(
      _digest: Arrayish
    ): Promise<{
      height: BigNumber;
      merkle: string;
      target: BigNumber;
      time: BigNumber;
      0: BigNumber;
      1: string;
      2: BigNumber;
      3: BigNumber;
    }>;

    headers(
      arg0: Arrayish
    ): Promise<{
      merkle: string;
      height: BigNumber;
      target: BigNumber;
      timestamp: BigNumber;
      chainWork: BigNumber;
      chainId: BigNumber;
      0: string;
      1: BigNumber;
      2: BigNumber;
      3: BigNumber;
      4: BigNumber;
      5: BigNumber;
    }>;

    isCorrectDifficultyTarget(
      prevStartTarget: BigNumberish,
      prevStartTime: BigNumberish,
      prevEndTarget: BigNumberish,
      prevEndTime: BigNumberish,
      nextTarget: BigNumberish,
      _height: BigNumberish
    ): Promise<{
      valid: boolean;
      update: boolean;
      0: boolean;
      1: boolean;
    }>;

    submitBlockHeader(
      _header: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    verifyTx(
      _height: BigNumberish,
      _index: BigNumberish,
      _txid: Arrayish,
      _proof: Arrayish,
      _confirmations: BigNumberish,
      _insecure: boolean
    ): Promise<boolean>;
  };

  CONFIRMATIONS(): Promise<BigNumber>;

  DIFFICULTY_ADJUSTMENT_INTERVAL(): Promise<BigNumber>;

  DIFF_TARGET(): Promise<BigNumber>;

  MAIN_CHAIN_ID(): Promise<BigNumber>;

  bestBlock(): Promise<string>;

  bestHeight(): Promise<BigNumber>;

  bestScore(): Promise<BigNumber>;

  chain(arg0: BigNumberish): Promise<string>;

  epochStartTarget(): Promise<BigNumber>;

  epochStartTime(): Promise<BigNumber>;

  forks(
    arg0: BigNumberish
  ): Promise<{
    height: BigNumber;
    ancestor: string;
    0: BigNumber;
    1: string;
  }>;

  getHashAtHeight(_height: BigNumberish): Promise<string>;

  getHeaderByHash(
    _digest: Arrayish
  ): Promise<{
    height: BigNumber;
    merkle: string;
    target: BigNumber;
    time: BigNumber;
    0: BigNumber;
    1: string;
    2: BigNumber;
    3: BigNumber;
  }>;

  headers(
    arg0: Arrayish
  ): Promise<{
    merkle: string;
    height: BigNumber;
    target: BigNumber;
    timestamp: BigNumber;
    chainWork: BigNumber;
    chainId: BigNumber;
    0: string;
    1: BigNumber;
    2: BigNumber;
    3: BigNumber;
    4: BigNumber;
    5: BigNumber;
  }>;

  isCorrectDifficultyTarget(
    prevStartTarget: BigNumberish,
    prevStartTime: BigNumberish,
    prevEndTarget: BigNumberish,
    prevEndTime: BigNumberish,
    nextTarget: BigNumberish,
    _height: BigNumberish
  ): Promise<{
    valid: boolean;
    update: boolean;
    0: boolean;
    1: boolean;
  }>;

  submitBlockHeader(
    _header: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  verifyTx(
    _height: BigNumberish,
    _index: BigNumberish,
    _txid: Arrayish,
    _proof: Arrayish,
    _confirmations: BigNumberish,
    _insecure: boolean
  ): Promise<boolean>;

  filters: {
    ChainReorg(
      _from: Arrayish | null,
      _to: Arrayish | null,
      _id: BigNumberish | null
    ): EventFilter;

    StoreHeader(
      _digest: Arrayish | null,
      _height: BigNumberish | null
    ): EventFilter;
  };

  estimate: {
    CONFIRMATIONS(): Promise<BigNumber>;

    DIFFICULTY_ADJUSTMENT_INTERVAL(): Promise<BigNumber>;

    DIFF_TARGET(): Promise<BigNumber>;

    MAIN_CHAIN_ID(): Promise<BigNumber>;

    bestBlock(): Promise<BigNumber>;

    bestHeight(): Promise<BigNumber>;

    bestScore(): Promise<BigNumber>;

    chain(arg0: BigNumberish): Promise<BigNumber>;

    epochStartTarget(): Promise<BigNumber>;

    epochStartTime(): Promise<BigNumber>;

    forks(arg0: BigNumberish): Promise<BigNumber>;

    getHashAtHeight(_height: BigNumberish): Promise<BigNumber>;

    getHeaderByHash(_digest: Arrayish): Promise<BigNumber>;

    headers(arg0: Arrayish): Promise<BigNumber>;

    isCorrectDifficultyTarget(
      prevStartTarget: BigNumberish,
      prevStartTime: BigNumberish,
      prevEndTarget: BigNumberish,
      prevEndTime: BigNumberish,
      nextTarget: BigNumberish,
      _height: BigNumberish
    ): Promise<BigNumber>;

    submitBlockHeader(_header: Arrayish): Promise<BigNumber>;

    verifyTx(
      _height: BigNumberish,
      _index: BigNumberish,
      _txid: Arrayish,
      _proof: Arrayish,
      _confirmations: BigNumberish,
      _insecure: boolean
    ): Promise<BigNumber>;
  };
}
